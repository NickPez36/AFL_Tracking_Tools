<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AFL Video Analysis Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .stat-btn, .quarter-btn, .control-btn { transition: all 0.2s ease-in-out; }
        .stat-btn:active, .control-btn:active { transform: scale(0.95); }
        .player-card.selected { background-color: #dbeafe; border-color: #3b82f6; transform: scale(1.02); }
        .quarter-btn.active { background-color: #16a34a; color: white; font-weight: 600; }
        .player-name-input { width: 100%; background-color: transparent; font-weight: 500; padding: 4px; border-radius: 4px; text-align: center; }
        .player-name-input:focus { background-color: #eef2ff; outline: none; box-shadow: 0 0 0 2px #3b82f6; }
        .player-name-input:read-only { cursor: pointer; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .modal-content { background: white; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 10px 25px rgba(0,0,0,0.1); max-width: 90%; width: 500px; text-align: center; }
        #videoDropZone, #timelineDropZone { border: 3px dashed #cbd5e1; transition: all 0.2s ease-in-out; }
        #videoDropZone.dragging, #timelineDropZone.dragging { border-color: #3b82f6; background-color: #eff6ff; }
        #timelineCanvas { cursor: pointer; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">AFL Video Analysis Tool</h1>
            <p class="text-lg text-gray-600 mt-2">Drop a video, code the game, and export your timeline.</p>
        </header>

        <!-- Match Setup Area -->
        <div class="bg-white p-6 rounded-lg shadow-lg mb-8">
            <h2 class="text-xl font-semibold mb-4 border-b pb-2">Match Setup</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <input type="text" id="matchTitle" placeholder="Match Title (e.g. Round 1 vs Swans)" class="w-full p-2 border border-gray-300 rounded-md">
                <div class="text-lg font-semibold text-gray-700 flex items-center">Team: Camden Cats</div>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="bg-white p-6 rounded-lg shadow-lg">
            <!-- Video Player and Drop Zone -->
            <div id="videoContainer" class="mb-6 w-full max-w-4xl mx-auto">
                <div id="videoDropZone" class="w-full aspect-video bg-gray-200 rounded-lg flex items-center justify-center text-gray-500 text-xl font-semibold">
                    <p id="dropZoneText">Drop Video File Here</p>
                    <video id="videoPlayer" class="w-full h-full rounded-lg hidden" controls></video>
                </div>
            </div>

            <!-- Player Selection Grid -->
            <div class="bg-gray-50 p-4 rounded-lg border mb-6">
                <div class="flex justify-between items-center mb-4 border-b pb-2">
                    <h2 class="text-xl font-semibold">Camden Cats Players</h2>
                    <p class="text-sm text-gray-500">Select a quarter to lock names. Click active quarter to unlock.</p>
                </div>
                <div id="playersList" class="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-11 gap-2"></div>
            </div>

            <!-- Coding Controls -->
            <div class="grid grid-cols-1 gap-6">
                <div class="bg-gray-50 p-4 rounded-lg border">
                    <div class="flex items-center mb-4">
                        <h2 class="text-xl font-semibold mr-4">Record Stat For:</h2>
                        <div id="selectedPlayerDisplay" class="text-xl font-bold text-blue-600">No Player Selected</div>
                    </div>
                    
                    <!-- Stat Buttons -->
                    <div id="statButtons" class="grid grid-cols-5 gap-3"></div>

                    <!-- Quarter Buttons -->
                    <div class="border-t pt-4 mt-4">
                         <h2 class="text-xl font-semibold mb-4 text-center">Quarter</h2>
                         <div class="grid grid-cols-4 gap-2">
                            <button id="q1" onclick="setQuarter(1)" class="quarter-btn border border-gray-300 py-2 rounded-md">Q1</button>
                            <button id="q2" onclick="setQuarter(2)" class="quarter-btn border border-gray-300 py-2 rounded-md">Q2</button>
                            <button id="q3" onclick="setQuarter(3)" class="quarter-btn border border-gray-300 py-2 rounded-md">Q3</button>
                            <button id="q4" onclick="setQuarter(4)" class="quarter-btn border border-gray-300 py-2 rounded-md">Q4</button>
                        </div>
                    </div>
                    
                    <!-- Whistle Button -->
                    <button onclick="recordEvent('Whistle')" class="control-btn w-full mt-4 bg-cyan-500 text-white font-bold py-3 rounded-lg">WHISTLE / BALL-UP</button>
                </div>
            </div>
        </div>

        <!-- Timeline Section -->
        <div id="timelineDropZone" class="mt-8 bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-2xl font-semibold mb-4">Timeline <span class="text-sm font-normal text-gray-500">(Drop saved XML here to load session)</span></h2>
            <canvas id="timelineCanvas" width="1200" height="300"></canvas>
            <input type="range" id="timelineScrubber" class="w-full mt-2" value="0" step="1">
        </div>
        
        <!-- Action Buttons Section -->
        <div class="mt-8 grid grid-cols-1 md:grid-cols-2 gap-6">
             <div class="bg-white p-4 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4">Timeline Actions</h2>
                <button onclick="clearTimeline()" class="w-full control-btn bg-gray-500 text-white px-4 py-2 rounded-md">Clear All Instances</button>
            </div>
            <div class="bg-white p-4 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4">Export</h2>
                <p class="text-gray-600 mb-4 text-sm">Generates a Sportscode-compatible XML file.</p>
                <button onclick="downloadXML()" class="w-full bg-indigo-600 text-white py-3 rounded-lg font-bold">Generate & Download XML</button>
            </div>
        </div>
    </div>
    
    <!-- Modals -->
    <div id="notificationModal" class="modal-overlay hidden"><div class="modal-content"><p id="modalMessage" class="text-lg"></p><button onclick="closeNotificationModal()" class="mt-4 bg-blue-500 text-white px-6 py-2 rounded-md">OK</button></div></div>
    <div id="editModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-2xl font-semibold mb-6">Edit Instance</h3>
            <div class="space-y-4 text-left">
                <div><label for="editPlayerSelect" class="block text-sm font-medium text-gray-700">Player</label><select id="editPlayerSelect" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm"></select></div>
                <div><label for="editStatSelect" class="block text-sm font-medium text-gray-700">Statistic</label><select id="editStatSelect" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm"></select></div>
            </div>
            <div class="mt-8 flex justify-between items-center">
                <button onclick="deleteInstance(eventToEditId, true)" class="bg-red-600 text-white px-6 py-2 rounded-md">Delete</button>
                <div>
                    <button onclick="closeEditModal()" class="bg-gray-300 text-gray-800 px-6 py-2 rounded-md mr-4">Cancel</button>
                    <button onclick="saveEdit()" class="bg-blue-600 text-white px-6 py-2 rounded-md">Save</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIG & STATE ---
        const STAT_TYPES = ['Kick', 'Handball', 'Mark', 'Inside 50', 'Tackle', 'Hit Out', 'Goal', 'Behind', 'Direct Turnover'];
        let matchData = { title: '', team: { name: 'Camden Cats', players: [] }, allEvents: [] };
        let currentQuarter = null;
        let selectedPlayerIndex = null;
        let eventToEditId = null;
        let isCanvasScrubbing = false;
        let rowMap = new Map();
        const ROW_HEIGHT = 20;
        const ROW_GAP = 5;
        const TIMELINE_WINDOW_SECONDS = 900; // 15 minutes
        let timelineWindowStartSeconds = 0;

        // --- DOM ELEMENTS ---
        const videoDropZone = document.getElementById('videoDropZone');
        const timelineDropZone = document.getElementById('timelineDropZone');
        const dropZoneText = document.getElementById('dropZoneText');
        const videoPlayer = document.getElementById('videoPlayer');
        const timelineCanvas = document.getElementById('timelineCanvas');
        const timelineScrubber = document.getElementById('timelineScrubber');
        const ctx = timelineCanvas.getContext('2d');
        const playersList = document.getElementById('playersList');
        const statButtonsContainer = document.getElementById('statButtons');
        const selectedPlayerDisplay = document.getElementById('selectedPlayerDisplay');
        const notificationModal = document.getElementById('notificationModal');
        const editModal = document.getElementById('editModal');
        const modalMessage = document.getElementById('modalMessage');
        const editPlayerSelect = document.getElementById('editPlayerSelect');
        const editStatSelect = document.getElementById('editStatSelect');

        // --- INITIALIZATION ---
        function initializeApp() {
            for (let i = 0; i < 22; i++) {
                matchData.team.players.push({ id: i, name: `Player ${i + 1}` });
            }
            STAT_TYPES.forEach(stat => {
                const btn = document.createElement('button');
                btn.textContent = stat;
                btn.onclick = () => recordEvent(stat);
                btn.className = 'stat-btn bg-blue-500 text-white p-3 rounded-lg shadow-sm font-semibold';
                if (['Inside 50'].includes(stat)) btn.className = btn.className.replace('bg-blue-500', 'bg-orange-500');
                if (['Tackle'].includes(stat)) btn.className = btn.className.replace('bg-blue-500', 'bg-red-500');
                if (['Direct Turnover'].includes(stat)) btn.className = btn.className.replace('bg-blue-500', 'bg-gray-800');
                if (['Hit Out'].includes(stat)) btn.className = btn.className.replace('bg-blue-500', 'bg-purple-500');
                if (['Goal', 'Behind'].includes(stat)) btn.className = btn.className.replace('bg-blue-500', 'bg-yellow-500 font-bold');
                if (stat === 'Goal') btn.className = btn.className.replace('bg-yellow-500', 'bg-green-600');
                statButtonsContainer.appendChild(btn);
            });
            renderPlayers();
            setupDragAndDrop();
            setupCanvasEvents();
            setupScrubberEvents();
            setupHotkeys(); // Add hotkey setup
            videoPlayer.addEventListener('timeupdate', () => {
                // Keep timeline window in sync with video
                if (!isCanvasScrubbing && document.activeElement !== timelineScrubber) {
                    const videoTime = videoPlayer.currentTime;
                    if (videoTime < timelineWindowStartSeconds || videoTime > timelineWindowStartSeconds + TIMELINE_WINDOW_SECONDS) {
                        timelineWindowStartSeconds = Math.floor(videoTime / TIMELINE_WINDOW_SECONDS) * TIMELINE_WINDOW_SECONDS;
                        timelineScrubber.value = timelineWindowStartSeconds;
                    }
                }
                drawTimeline();
            });
            videoPlayer.addEventListener('loadedmetadata', () => {
                timelineCanvas.height = Math.max(300, (matchData.team.players.length + 2) * (ROW_HEIGHT + ROW_GAP));
                timelineScrubber.max = Math.max(0, videoPlayer.duration - TIMELINE_WINDOW_SECONDS);
                drawTimeline();
            });
        }

        // --- HOTKEYS ---
        function setupHotkeys() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger hotkeys if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                    return;
                }

                switch (e.key) {
                    case ' ': // Space bar
                        e.preventDefault(); // Prevent page scroll
                        if (videoPlayer.paused) {
                            videoPlayer.play();
                        } else {
                            videoPlayer.pause();
                        }
                        break;
                    
                    case 'ArrowLeft':
                        e.preventDefault();
                        videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 0.5);
                        break;
                    
                    case 'ArrowRight':
                        e.preventDefault();
                        if (videoPlayer.duration) {
                           videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 0.5);
                        }
                        break;
                }
            });
        }

        // --- FILE HANDLING ---
        function setupDragAndDrop() {
            // Video Drop
            videoDropZone.addEventListener('dragover', (e) => { e.preventDefault(); videoDropZone.classList.add('dragging'); });
            videoDropZone.addEventListener('dragleave', () => { videoDropZone.classList.remove('dragging'); });
            videoDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                videoDropZone.classList.remove('dragging');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('video/')) {
                    const videoURL = URL.createObjectURL(file);
                    videoPlayer.src = videoURL;
                    videoPlayer.classList.remove('hidden');
                    dropZoneText.classList.add('hidden');
                } else {
                    showNotification('Please drop a valid VIDEO file.');
                }
            });
            // XML Drop
            timelineDropZone.addEventListener('dragover', (e) => { e.preventDefault(); timelineDropZone.classList.add('dragging'); });
            timelineDropZone.addEventListener('dragleave', () => { timelineDropZone.classList.remove('dragging'); });
            timelineDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                timelineDropZone.classList.remove('dragging');
                const file = e.dataTransfer.files[0];
                if (file && (file.type === 'text/xml' || file.name.endsWith('.xml'))) {
                    loadXML(file);
                } else {
                     showNotification('Please drop a valid XML file on the timeline area.');
                }
            });
        }

        // --- CORE APP LOGIC ---
        function renderPlayers() {
            const isLocked = currentQuarter !== null;
            playersList.innerHTML = '';
            matchData.team.players.forEach((player, index) => {
                const isSelected = selectedPlayerIndex === index;
                const card = document.createElement('div');
                card.className = `player-card p-2 border-2 border-gray-300 rounded-md cursor-pointer ${isSelected ? 'selected' : ''}`;
                card.onclick = () => selectPlayer(index);
                card.innerHTML = `<input type="text" class="player-name-input" value="${escapeXml(player.name)}" onchange="updatePlayerName(${index}, this.value)" onclick="handleInputClick(event, ${index})" ${isLocked ? 'readonly' : ''}>`;
                playersList.appendChild(card);
            });
        }
        
        function handleInputClick(event, index) {
            const isLocked = currentQuarter !== null;
            if (isLocked) {
                selectPlayer(index);
            } else {
                event.stopPropagation();
            }
        }

        function updatePlayerName(index, newName) {
            matchData.team.players[index].name = newName.trim();
            if (selectedPlayerIndex === index) selectedPlayerDisplay.textContent = newName;
            drawTimeline();
        }

        function selectPlayer(index) {
            const isLocked = currentQuarter !== null;
            if (!isLocked) return;
            selectedPlayerIndex = index;
            selectedPlayerDisplay.textContent = matchData.team.players[index].name;
            renderPlayers();
        }

        function setQuarter(quarter) {
            if (currentQuarter === quarter) {
                currentQuarter = null;
            } else {
                currentQuarter = quarter;
            }
            document.querySelectorAll('.quarter-btn').forEach(btn => btn.classList.remove('active'));
            if (currentQuarter) {
                document.getElementById(`q${currentQuarter}`).classList.add('active');
            }
            renderPlayers();
        }

        function recordEvent(type) {
            if (!videoPlayer.src) { showNotification('Please load a video first.'); return; }
            if (!currentQuarter) { showNotification('Please select a quarter first.'); return; }
            if (type !== 'Whistle' && selectedPlayerIndex === null) { showNotification('Please select a player first.'); return; }
            
            const recordedTime = videoPlayer.currentTime;
            const isWhistle = type === 'Whistle';
            
            matchData.allEvents.push({
                id: crypto.randomUUID(),
                type: type,
                playerIndex: isWhistle ? null : selectedPlayerIndex,
                quarter: currentQuarter,
                startTimeSeconds: isWhistle ? recordedTime : Math.max(0, recordedTime - 5),
                endTimeSeconds: isWhistle ? recordedTime + 1 : recordedTime + 5,
            });
            drawTimeline();
        }

        // --- CANVAS & TIMELINE ---
        function drawTimeline() {
            if (!videoPlayer.duration) return;
            const W = timelineCanvas.width;
            const H = timelineCanvas.height;
            ctx.clearRect(0, 0, W, H);

            rowMap.clear();
            let rowIndex = 0;
            rowMap.set('Whistle', rowIndex++);
            matchData.team.players.forEach((player, index) => rowMap.set(index, rowIndex++));
            
            ctx.font = '10px Inter';
            ctx.fillStyle = '#6b7280';
            for (const [key, index] of rowMap.entries()) {
                const y = index * (ROW_HEIGHT + ROW_GAP) + ROW_HEIGHT / 2;
                const label = key === 'Whistle' ? 'Whistle' : matchData.team.players[key]?.name || 'Unknown';
                ctx.fillText(label, 5, y + 4);
                ctx.strokeStyle = '#e5e7eb';
                ctx.beginPath();
                ctx.moveTo(100, y - ROW_HEIGHT/2 + 0.5);
                ctx.lineTo(W, y - ROW_HEIGHT/2 + 0.5);
                ctx.stroke();
            }

            matchData.allEvents.forEach(event => {
                if (event.endTimeSeconds < timelineWindowStartSeconds || event.startTimeSeconds > timelineWindowStartSeconds + TIMELINE_WINDOW_SECONDS) return;
                const isWhistle = event.type === 'Whistle';
                const rowKey = isWhistle ? 'Whistle' : event.playerIndex;
                const rowIndex = rowMap.get(rowKey);
                if (rowIndex === undefined) return;

                const y = rowIndex * (ROW_HEIGHT + ROW_GAP);
                const x = 100 + ((event.startTimeSeconds - timelineWindowStartSeconds) / TIMELINE_WINDOW_SECONDS) * (W - 100);
                const w = ((event.endTimeSeconds - event.startTimeSeconds) / TIMELINE_WINDOW_SECONDS) * (W - 100);
                
                ctx.fillStyle = isWhistle ? '#06b6d4' : '#3b82f6';
                ctx.fillRect(x, y, Math.max(2, w), ROW_HEIGHT);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Inter';
                ctx.fillText(event.type, x + 4, y + ROW_HEIGHT / 2 + 4);
            });

            const playheadX = 100 + ((videoPlayer.currentTime - timelineWindowStartSeconds) / TIMELINE_WINDOW_SECONDS) * (W - 100);
            if (playheadX >= 100 && playheadX <= W) {
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(playheadX, 0);
                ctx.lineTo(playheadX, H);
                ctx.stroke();
                ctx.lineWidth = 1;
            }
        }

        function setupCanvasEvents() {
            timelineCanvas.addEventListener('mousedown', e => {
                const rect = timelineCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                if (x < 100) return;
                isCanvasScrubbing = true;
                scrubVideo(x);
            });
            document.addEventListener('mousemove', e => {
                if (!isCanvasScrubbing) return;
                const rect = timelineCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                scrubVideo(x);
            });
            document.addEventListener('mouseup', () => { isCanvasScrubbing = false; });
            timelineCanvas.addEventListener('click', e => {
                if (isCanvasScrubbing) return;
                const rect = timelineCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const clickedEvent = findEventAt(x, y);
                if (clickedEvent) {
                    openEditModal(clickedEvent.id);
                }
            });
        }

        function scrubVideo(mouseX) {
            if (!videoPlayer.duration) return;
            const W = timelineCanvas.width;
            const timelineX = Math.max(100, Math.min(W, mouseX));
            const timeRatio = (timelineX - 100) / (W - 100);
            videoPlayer.currentTime = timelineWindowStartSeconds + (timeRatio * TIMELINE_WINDOW_SECONDS);
        }

        function setupScrubberEvents() {
            timelineScrubber.addEventListener('input', () => {
                timelineWindowStartSeconds = parseFloat(timelineScrubber.value);
                drawTimeline();
            });
        }
        
        function findEventAt(mouseX, mouseY) {
            if (!videoPlayer.duration) return null;
            const W = timelineCanvas.width;
            for (const event of matchData.allEvents) {
                const isWhistle = event.type === 'Whistle';
                const rowKey = isWhistle ? 'Whistle' : event.playerIndex;
                const rowIndex = rowMap.get(rowKey);
                if (rowIndex === undefined) continue;
                if (event.endTimeSeconds < timelineWindowStartSeconds || event.startTimeSeconds > timelineWindowStartSeconds + TIMELINE_WINDOW_SECONDS) continue;
                const y = rowIndex * (ROW_HEIGHT + ROW_GAP);
                const x = 100 + ((event.startTimeSeconds - timelineWindowStartSeconds) / TIMELINE_WINDOW_SECONDS) * (W - 100);
                const w = ((event.endTimeSeconds - event.startTimeSeconds) / TIMELINE_WINDOW_SECONDS) * (W - 100);
                if (mouseX >= x && mouseX <= x + w && mouseY >= y && mouseY <= y + ROW_HEIGHT) return event;
            }
            return null;
        }

        // --- EDITING & DELETION ---
        function deleteInstance(eventId, fromModal = false) {
            matchData.allEvents = matchData.allEvents.filter(event => event.id !== eventId);
            if(fromModal) closeEditModal();
            drawTimeline();
        }

        function clearTimeline() { matchData.allEvents = []; drawTimeline(); }

        function openEditModal(eventId) {
            const event = matchData.allEvents.find(e => e.id === eventId);
            if (!event) return;
            eventToEditId = eventId;
            const isWhistle = event.type === 'Whistle';
            editPlayerSelect.innerHTML = '';
            matchData.team.players.forEach((p, index) => {
                editPlayerSelect.innerHTML += `<option value="${index}" ${event.playerIndex === index ? 'selected' : ''}>${escapeXml(p.name)}</option>`;
            });
            editPlayerSelect.disabled = isWhistle;
            const eventTypes = isWhistle ? ['Whistle'] : STAT_TYPES;
            editStatSelect.innerHTML = '';
            eventTypes.forEach(type => {
                editStatSelect.innerHTML += `<option value="${type}" ${event.type === type ? 'selected' : ''}>${type}</option>`;
            });
            editStatSelect.disabled = isWhistle;
            editModal.classList.remove('hidden');
        }

        function closeEditModal() { editModal.classList.add('hidden'); eventToEditId = null; }

        function saveEdit() {
            const event = matchData.allEvents.find(e => e.id === eventToEditId);
            if (!event || event.type === 'Whistle') { closeEditModal(); return; }
            event.playerIndex = parseInt(editPlayerSelect.value, 10);
            event.type = editStatSelect.value;
            closeEditModal();
            drawTimeline();
        }

        // --- XML IMPORT/EXPORT ---
        function loadXML(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(e.target.result, "application/xml");
                    
                    // First, extract all unique player names from the XML
                    const rows = xmlDoc.getElementsByTagName('row');
                    const playerNamesFromXML = [];
                    for (const row of rows) {
                        const code = row.getElementsByTagName('code')[0].textContent;
                        if (code !== 'Whistle' && !STAT_TYPES.includes(code)) {
                            playerNamesFromXML.push(code);
                        }
                    }

                    // Update the player roster in matchData
                    playerNamesFromXML.forEach((name, index) => {
                        if (matchData.team.players[index]) {
                            matchData.team.players[index].name = name;
                        }
                    });
                    renderPlayers(); // Update the UI with new player names

                    // Now, process the instances
                    const instances = xmlDoc.getElementsByTagName('instance');
                    if (instances.length === 0) {
                        showNotification('No instances found in the XML file.');
                        return;
                    }
                    matchData.allEvents = [];
                    for (const instance of instances) {
                        const start = parseFloat(instance.getElementsByTagName('start')[0].textContent);
                        const end = parseFloat(instance.getElementsByTagName('end')[0].textContent);
                        const code = instance.getElementsByTagName('code')[0].textContent;
                        const labels = instance.getElementsByTagName('label');
                        let quarter = 0;
                        let statType = '';
                        for(const label of labels) {
                            if(label.getElementsByTagName('group')[0].textContent === 'Quarter') quarter = parseInt(label.getElementsByTagName('text')[0].textContent.replace('Q',''));
                            if(label.getElementsByTagName('group')[0].textContent === 'Stat') statType = label.getElementsByTagName('text')[0].textContent;
                        }
                        const isWhistle = code === 'Whistle';
                        let playerIndex = null;
                        if (!isWhistle) {
                            // Find the player index from the now-updated roster
                            playerIndex = matchData.team.players.findIndex(p => p.name === code);
                            if (playerIndex === -1) {
                                console.warn(`Player "${code}" not found in current roster. Skipping instance.`);
                                continue;
                            }
                        }
                        matchData.allEvents.push({
                            id: crypto.randomUUID(),
                            type: isWhistle ? 'Whistle' : statType,
                            playerIndex: playerIndex,
                            quarter: quarter,
                            startTimeSeconds: start,
                            endTimeSeconds: end,
                        });
                    }
                    drawTimeline();
                    showNotification(`Successfully loaded ${matchData.allEvents.length} instances.`);
                } catch (err) {
                    showNotification('Error parsing XML file. Please ensure it is a valid file from this tool.');
                    console.error("XML Parsing Error:", err);
                }
            };
            reader.readAsText(file);
        }

        function generateXML() {
            matchData.title = document.getElementById('matchTitle').value || 'Untitled Match';
            let instanceId = 1;
            let allInstancesXml = '';
            const uniqueCodes = new Set();
            
            const sortedEvents = [...matchData.allEvents].sort((a, b) => a.startTimeSeconds - b.startTimeSeconds);
            sortedEvents.forEach(event => {
                const isWhistle = event.type === 'Whistle';
                const code = isWhistle ? 'Whistle' : matchData.team.players[event.playerIndex]?.name;
                if (!code) return;
                uniqueCodes.add(code);
                if (!isWhistle) uniqueCodes.add(event.type);
                allInstancesXml += `    <instance>\n      <ID>${instanceId++}</ID>\n      <start>${event.startTimeSeconds}</start>\n      <end>${event.endTimeSeconds}</end>\n      <code>${escapeXml(code)}</code>\n`;
                if (!isWhistle) allInstancesXml += `      <label><group>Stat</group><text>${escapeXml(event.type)}</text></label>\n`;
                allInstancesXml += `      <label><group>Quarter</group><text>Q${event.quarter}</text></label>\n    </instance>\n`;
            });
            let rowsXml = '';
            uniqueCodes.forEach(code => { rowsXml += `    <row><code>${escapeXml(code)}</code></row>\n`; });
            return `<?xml version="1.0" encoding="UTF-8"?>\n<file>\n  <ALL_INSTANCES>\n${allInstancesXml}  </ALL_INSTANCES>\n  <ROWS>\n${rowsXml}  </ROWS>\n</file>`;
        }

        function downloadXML() {
            const xmlString = generateXML();
            const blob = new Blob([xmlString], { type: 'text/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const safeTitle = (document.getElementById('matchTitle').value || 'camden-cats-stats').replace(/[^a-z0-9]/gi, '_').toLowerCase();
            a.download = `${safeTitle}.xml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- HELPERS ---
        function showNotification(message) { modalMessage.textContent = message; notificationModal.classList.remove('hidden'); }
        function closeNotificationModal() { notificationModal.classList.add('hidden'); }
        function formatTime(s) { return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }
        function escapeXml(unsafe) { return unsafe.replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','\'':'&apos;','"':'&quot;'}[c])); }
        
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
